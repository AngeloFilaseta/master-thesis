%!TEX root = ../thesis-main.tex
\chapter{Analysis}
\label{chap:analysis}
\section{APM Approach and Proof of Concept}
\label{sec:apm-approach-and-proof-of-concept}
The goal to reach is evident, however, creating a solution for the problem is pretty difficult as numerous technologies and methodologies are available, making it challenging to determine the optimal one. In these cases it can be useful to use an \textbf{Agile Project Management (APM)} approach. By breaking down the solution into smaller steps, it becomes possible to review the accuracy of each step with the party that requested the project.\newline

The code for this Alchemist sub-project is managed through a collaborative process that involves submitting changes via pull requests directly inside the main repository. Before the code is published, it is reviewed to ensure that it meets quality standards and it aligns with the project goals. The pushed code also goes through a quality assurance process. This process is automated and triggered by the continuous integration (CI) system, which runs a series of tests and checks out the code. The CI system uses multiple quality assurance systems and static code analysis tools to verify the code for potential bugs, security issues, and other potential problems. This helps to ensure that only high-quality code is merged into the main repository and ultimately published.\newline

Since the solution to the problem is not clear, the first step in the development process is to create a working proof of concept. A \textbf{Proof of Concept (PoC)} is an incomplete or rough version of a certain project or method. This is commonly used when it is necessary to verify that a certain idea is feasible from a technical point of view, for example when a new technology is needed and success is uncertain.\newline

Generally, in a PoC it would be necessary to postpone as much as possible the technical aspects, but in this case it is better to understand right away how risky these technical aspects could be. Choosing a specific technology is a very important condition of satisfaction. The whole system is not created, however an effort is made to minimize the work by trying to understand what the critical points are. An example could be that of creating and applying the uncertain algorithm by using data that are not necessarily part of the domain of interest. The risk is reduced when, analyzing the performance, good results are obtained. The key point is the minimization of work, but it is necessary to simulate the system in such a way that it is as close as possible to the real one~\cite{slides-scoping}.\newline

There are ton of possibilities when creating an architecture. However there are some technological constraints that limit the number of possible solutions that can be designed:
\begin{itemize}
	\item The Alchemist Simulator technology stack is based on the JVM. Additional tools for data conversion are surely required to interoperate with other components that uses a different technology stack;
	\item The Renderer of the system must be as flexible as possible, it should run on a JVM and in a Web Environment at least. The most used languages for web development are Javascript and Web Assembly (Wasm).
\end{itemize}

The architecture design of the first proof of concept tries to reuse as much as possible the existing structures in the Alchemist codebase, shifting the issues of conversion and interoperability  onto the yet-to-exist renderer component. In this architecture idea the Renderer is a component, written using a JVM language, which requires an \textit{Environment} and offers an \textit{Image} in any format depending on the implementation. It could be a raster image, or even better, any sort or scalable format, like an SVG string. The Renderer can be visualized as a UML Component in \fullref{fig:jvm-renderer}.

\centerImage{figures/jvmRendererComponent.png}{UML Component - JVM Renderer Component}{jvm-renderer}{0.5}

The architecture shown in the UML component diagram in \fullref{fig:proof} is representative of the idea of using a \textit{transpiler} to create another Renderer component in a web language starting from its JVM implementation. If the \textit{Transpiled Renderer} is converted successfully, it will be possible to use the \textit{Renderer} component on both the server and the client machine.

\begin{info}[Transpiler:]
	Also known as a source-to-source compiler, it is a type of compiler that takes source code written in one programming language and converts it into another. JVM languages and JavaScript are very different in terms of syntax and semantics. However, it is possible to achieve a Java to JavaScript conversion using a transpiler.
	Usually, a transpiler works by mapping the first language constructs and APIs to the equivalent constructs and APIs of the second language even thought every transpiler is different and can offer different features that are not entirely supported by others.
\end{info}

\centerImage{figures/proof.png}{UML Component Diagram - First Proof of Concept Architecture}{proof}{1}

In this architecture, the \textit{Server} component interacts with the \textit{Simulation} component, obtaining the Environment which must be rendered every time it get updated by a reaction. As said before, the \textit{Renderer} component is also written in a JVM language and can interact with Alchemist structures without problems. The \textit{Client} component is able to communicate with the \textit{Server} component by using the API endpoints that the latter offers. The \textit{Transpiled Renderer} component is the JS or TS implementation of the \textit{Renderer} component and is automatically generated by an external \textit{Transpiler} component that must be identified.\newline

The UML Component Diagram is optimal for visualizing the high level architecture of the systems and the dependencies between components. However, this type of representation is unable to show how the components interact with each other in detail. Therefore, the following is a brief description of how the two previously described approaches (Stadia-like and Everything in Browser) would work at a low and more implementative level:
\begin{itemize}
	\item \textbf{Stadia-like approach}: this case is not problematic at all. The \textit{Server} component and the \textit{Renderer} component are compatible. When needed, the Server can ask the \textit{Renderer} component to generate a visual representation of the Environment, serialize it, and send it to the \textit{Client} module using any transmission network protocol, like HTTP. Once the image is received, the Client just needs to make it visible on the front-end;
	\item \textbf{Everything in Browser approach}: this case is a bit more problematic in terms of implementation because the \textit{Renderer} module and the \textit{Client} module use a completely different technology stack that are not compatible with each other. The \textit{Transpiled Renderer} must be used, meaning that the existence of a \textit{Transpiler} which can generate the JS/TS component is a strict requirement for this solution to be considered feasible.
	By taking this for granted, the \textit{Server} module can send a serialized form of the \textit{Environment} to the \textit{Client} module (even Java serialization is fine). Eventually, the Client will create the image and make it visible on the front-end.
\end{itemize}
\sectionmark{Comparative Study of Transpilation [...]}
\section{Comparative Study of Transpilation Technologies and Alternatives}
\label{sec:comparative-study-of-transpilation-technologies-and-alternatives}
\sectionmark{Comparative Study of Transpilation [...]}
With so many transpilers available, it can be overwhelming to choose the right one for the project.  To ensure that the best choice is made, a comparative study was conducted to evaluate the strengths and weaknesses of each transpiler.  Through this analysis, conclusions were drawn to determine the most suitable option for this project. These are the technologies that were taken into consideration for the creation of the first PoC:
\begin{itemize}
	\item \textbf{DoppioJVM}: an open-source project that aims to provide a fully-featured Java Virtual Machine (JVM) written entirely in JavaScript~\cite{DoppioJV33:online};
	\item \textbf{JSweet}: a Java to JavaScript transpiler that converts Java source code to JavaScript source code~\cite{JSweetat88:online};
	\item \textbf{TeaVM}: a Java to JavaScript transpiler that translates Java bytecode to JavaScript;
	\item \textbf{J2CL}: a Google-made transpiler that converts Java source code to JavaScript, using the Closure Library~\cite{googlej257:online}.
\end{itemize}
All the listed technologies will be described in the following subsections. Although they are all good options in certain situations, none of them fulfilled the requirements of the Alchemist project. The motivations behind this choice are explained in the conclusions paragraph of each tool.
\subsection{DoppioJVM}
\label{ssec:doppiojvm}
Doppio is a JavaScript-based runtime system that enables the execution of unaltered general-purpose apps inside the browser. Two case studies have been used to illustrate the value of Doppio:
\begin{itemize}
	\item An \emph{Emscripten extension with Doppio} has been created to execute unmodified C++ application in the browser with full functionality;
	\item \emph{DoppioJVM}~\cite{DoppioJV33:online} is an interpreter written in Typescript that runs unmodified JVM programs directly in the browser.
\end{itemize}

DoppioJVM can work with the JavaScript environment in addition to running programs that are entirely written in a JVM language. JavaScript snippets can be executed by JVM programs using the \kotlin{eval} method which DoppioJVM exposes. This method returns a JVM String, which is the operation's return value converted to string format. A JavaScript program can also use DoppioJVM to execute a JVM program similarly to how one would call Java on the command line through an API: the programmer specifies the classpath, main class, arguments, and, optionally, custom functions to reroute standard input and output~\cite{doppio}.\newline

DoppioJVM is not a transpiler. The Java code is executed directly by a Java Virtual Machine that runs on JavaScript. This means that the resulting output can be used directly in a JavaScript environment without the need for a transpiled renderer component. The architecture previously described may require some adjustments, but the adopted strategy remains unchanged.\newline

Summing up, if DoppioJVM is successful in providing a way to run Java code in a JavaScript environment, the ``Transpiled Renderer" component would not be necessary, as the original renderer component would be used directly. This would also simplify the development process and reduce the complexity of the overall solution.

\paragraph{Strengths} DoppioJVM boasts the following strengths:
\begin{itemize}
	\item \textbf{Cross-platform}: Because DoppioJVM is written in JavaScript, it can run on any platform that has a JavaScript runtime environment, such as web browsers and Node.js. This allows developers to write Java code that can run in a wide variety of environments without the need for a separate Java installation;
	\item \textbf{No need for a separate Java installation}: Because DoppioJVM is a self-contained JVM implementation, it does not require a separate Java installation, which can simplify deployment and reduce the number of dependencies required to run Java code;
	\item \textbf{Depends on Bytecode}: Since DoppioJVM implements all the bytecode instructions specified in the second edition of the Java Virtual Machine Specification, even Kotlin and Scala could be transpiled.
\end{itemize}
\paragraph{Weaknesses and Limitations} DoppioJVM has the following weaknesses and limitations:
\begin{itemize}
	\item \textbf{Unmaintained}: The project is poorly maintained. New features that may be added to Java will probably never be supported;
	\item \textbf{Performance}: When running CPU-intensive benchmarks in Google Chrome, DoppioJVM is between 24 and 42 times slower than a native JVM. This can be especially true for CPU-intensive tasks or large-scale application;
	\item \textbf{Memory usage}: JavaScript runtime environments typically have less memory available than native environments, which can limit the size and complexity of the applications that can be run with DoppioJVM;
	\item \textbf{Time Wasting}: Once a JVM finishes a computation, it is not possible to re-use the already instantiated VM object. Instead, a new VM instance must be spawned. As a result, in certain situations, more time could be wasted;
	\item \textbf{Lack of support for lot of Java features}: DoppioJVM may not support all of the features of the Java language or the Java Virtual Machine, which can limit the types of Java code that can be run with it;
	\item \textbf{Compatibility}: DoppioJVM is probably not compatible with lots of Java libraries or frameworks, especially those that rely on features not available in the JavaScript runtime environment. Moreover, some Java versions are not supported at all.
\end{itemize}
\paragraph{Conclusion} DoppioJVM has been tested for the creation of a simple Render prototype, but it was clear from the beginning that it was not a good technology choice. The Alchemist codebase can not be considered small and simple enough for a solution like this to be reliable. Loading and starting a JVM instance takes a considerable and non-negligible amount of time in the scale of the seconds. On the other hand, the Alchemist Environment can be updated by the Simulation lots of times in a matter of a single second.
Finally, even the simpler prototype of a Renderer component never worked on a web environment in the first place. Lots of Exception have been thrown, probably because of an incompatibility with some feature used by some Alchemist classes. The Exception stack-trace was never really clear about what the error was. All these difficulties in the early stages of the development, were a big red flag. Therefore, the idea of using the DoppioJVM library has been dropped rapidly.
\subsection{JSweet}
\label{ssec:jsweet}
JSweet~\cite{JSweetat88:online} is a powerful tool that allows for code-to-code transpilation from Java to JavaScript. The transpilation process results in clean and readable JavaScript code that can be easily maintained and extended. With JSweet, developers can enjoy the benefits of JVM languages features, like strong type checking and familiar development tools, while still being able to target the web and interact with JavaScript libraries and APIs.
\paragraph{Strengths} Jsweet is a useful tool because of its many advantages:
\begin{itemize}
	\item\textbf{Object oriented and well-typed}: JSweet exploits Java's object-oriented features and strong type checking for efficient and error-free JavaScript programming with clear and organized code;
	\item \textbf{Clean JavaScript/TypeScript output}: The generated JavaScript/TypeScript code is very programmer-friendly;
	\item \textbf{Interoperability}: The generated JavaScript code is independent of any Java API. Unlike other transpilers, JSweet is engineered to have minimal interference with JavaScript, making it effortless to access the generated APIs/objects directly from JavaScript, without needing additional tools or runtimes;
	\item \textbf{Extensibility}: JSweet is an open-source transpiler that allows customization through extensions to enhance the generated code and support a wider range of APIs, libraries, contexts, and use cases;
	\item \textbf{JSDoc Support}: JSweet maps JavaDoc comments to JSDoc comments;
	\item \textbf{Source maps}: Generates source maps useful to debug the original Java code when running within a browser;
	\item \textbf{Node.js, Angular and modules}: Generates a web bundle for compatibility with any browser, as well as CommonJS modules which can be used with Node.js, Angular 2+, and other similar frameworks.
\end{itemize}

\paragraph{Weaknesses and Limitations} Jsweet also lacks in some aspects:
\begin{itemize}
	\item \textbf{Sub-optimal mapping}: It is important to keep in mind that there is no exact replication of Java within JSweet and the output of a JSweet program is essentially a standard JavaScript program. This has its advantages, but it also means that there may be small variations in behavior compared to Java programs (i.e., JSweet cannot distinguish between a Long and an Int at runtime, affecting method overloading). However, JSweet strives to ensure that its programs behave similarly to Java programs in most cases, making it simple to run the same code on a JRE or in a JS container;
	\item \textbf{Poor Library support}: Basic support for common Java APIs can be found in the J4TS~\cite{j4tsj4ts87:online} project. It is expected that more APIs will be supported in the future, however, it is impossible to cover all the libraries out there;
	\item \textbf{Works only with Java}: JSweet does not rely on bytecode for the transpilation process. Only the Java syntax is supported and accepted as input, meaning that languages like Scala and Kotlin are not supported. This leads to the addition of an implementative requirement that results in a heavy constraint.
\end{itemize}

\paragraph{Conclusion} The Alchemist Simulator project depends on a lot of external dependencies, making JSweet a very doubtful option. Furthermore, a significant amount of Kotlin code in the Alchemist codebase would not be supported by the transpilation process and would have to be rewritten. Additionally, the uncertain nature of how code will be translated by JSweet makes it a less suitable option for a simulator, which requires precision in its operations. As JSweet only provides a subset of the Java language and may produce JavaScript code that behaves differently from the original Java code, there is a risk that the simulator's operations could be translated in an unexpected or incorrect manner. The precision and reliability of a simulator is crucial, as it is used to model real-world systems and predict their behavior. The uncertainty in the translation of code in JSweet may result in inaccuracies in the simulation visualization, compromising the reliability and validity of the results shown.\newline

Because of the above-mentioned reasons, it may be advisable to consider alternative options that provide greater precision and reliability in the translation of code and that can better support external dependencies.

\subsection{TeaVM}
\label{ssec:teavm}
TeaVM~\cite{TeaVM77:online} is a ahead-of-time compiler for Java bytecode that generates JavaScript and WebAssembly. The key difference from all the other transpiler is that TeaVM only requires compiled class files, not source code. For this reason, TeaVM can compile Kotlin and Scala, not just Java. TeaVM can be used in the following scenarios:
\begin{itemize}
	\item A web front-end is needed from scratch;
	\item A Java-based back-end already exists and it is needed to integrate front-end code tightly into your existing development infrastructure;
	\item It would be optimal to reuse some Java back-end code in the front end.
\end{itemize}

\paragraph{Strengths} TeaVM has some relevant and interesting advantages:
\begin{itemize}
	\item \textbf{Depends on Bytecode}: The transpilation process uses bytecode to create Javascript artifacts, meaning languages like Kotlin and Scala could be used successfully;
	\item \textbf{Included Web framework}: it is possible to develop single-page web applications using Flavour, a framework available in Java, Kotlin, or Scala. The framework offers a similar experience to Angular, React.js or Vue.js, but with a Java-based syntax;
	\item \textbf{Efficient}: TeaVM is efficient and won't take hours to compile. It generates fast, lightweight JavaScript code for web applications, ensuring quick load times, even on mobile devices;
	\item \textbf{Readable structure}: TeaVM aims to preserve the original structure of a method, resulting in JavaScript that is easy to read and eventually debug;
	\item \textbf{Optimized}: TeaVM uses a very sophisticated optimizer;
	\item \textbf{Thread Support}: JavaScript lacks APIs for thread creation (WebWorkers, while similar, do not allow for sharing of state between workers). On the other hand, TeaVM supports threading. This is possible thanks to the continuation-passing style, which enables a sort of emulation of multiple logical threads in one physical thread;
	\item \textbf{Source maps}: TeaVM IDEA plugin allows the debugging of code right from the IDE, similarly to JSweet.
\end{itemize}
\paragraph{Weaknesses and Limitations} While TeaVM provides several benefits, there are also some considerable drawbacks:
\begin{itemize}
	\item \textbf{Need of Additional setup}: Some code may need to be rewritten to ensure proper functioning of TeaVM;
	\item \textbf{Limited Library Support}: Like JSweet, TeaVM has limited support for external libraries, meaning that lots of them will not work on a browser;
	\item\textbf{Lack of Gradle Plugin}: TeaVM currently supports only a Maven plugin. This can make the process of integrating it into a different build system a bit challenging;
	\item \textbf{Non-Standard Framework}: TeaVM uses a framework that is not widely used by other applications. This can result in difficulties in finding support or integration with other tools and systems;
	\item \textbf{Lack of some Java Feature Support}: Some Java features, such as reflections, are not fully supported by TeaVM. This can result in limitations in the functionality of Java applications when compiled to JavaScript, and can also make it more challenging to port existing Java code to run in the browser, especially if the JVM codebase already exists.
\end{itemize}
\paragraph{Conclusions} In the context of the Alchemist project, it was determined that certain Java features were imperative for the desired functionality. Upon evaluation, it was found that TeaVM was not capable of supporting some of these crucial features. Furthermore, TeaVM was unable to meet the demands of all the necessary external dependencies required by the project. Consequently, it was chosen not to use TeaVM in the Alchemist project due to its obvious limitations.
\subsection{J2CL}
\label{ssec:j2cl}
Google Web Toolkit (GWT)~\cite{GWT93:online} is a development toolkit for building and optimizing complex browser-based applications. In early 2015, the Google GWT team faced a significant challenge when they realized that the current trend in the web ecosystem and the demands of their internal customers required a new approach to Java on the Web. To address this, they made the difficult decision of developing a new product that would better align with the larger technology stack and meet the needs of their customers.\newline

J2CL~\cite{googlej257:online} (Closure Compiler~\cite{googlecl76:online}) is the new transpiler for Java made by Google that allows to convert Java code to JavaScript. J2CL works by taking Java source code and transforming it into equivalent JavaScript code that can be executed in a web browser or in other JavaScript runtime environments. J2CL uses the Closure Compiler, which performs optimizations on the generated code to make it more compact and efficient. J2CL also provides a Java-like runtime environment that emulates the behavior of Java classes in JavaScript, so that Java code can run in the browser as if it were running on the JVM. This allows developers to write Java code and reuse existing Java libraries, while still taking advantage of the reach and flexibility of the web.

\paragraph{Strenghts} J2CL has some notable qualities:
\begin{itemize}
	\item \textbf{Flexible}: J2CL offers complete flexibility in terms of usage. It is possible to make just a part of Java code available to JavaScript, or utilize it to create an entire application, depending on the specific need;
	\item \textbf{Global dead code elimination}: J2CL optimizes for dead code elimination, meaning that unused code can be automatically removed from the compiled output, resulting in smaller and faster applications;
	\item \textbf{Road tested and trusted}: J2CL powers the most sophisticated GSuite applications developed by Google, including GMail, Inbox, Docs, Slides, and Calendar.
\end{itemize}

\paragraph{Weaknesses and Limitations} J2CL has some known and documented limitations~\cite{j2cllimi50:online}, including:
\begin{itemize}
	\item \textbf{Limited support on Java Libraries}: J2CL currently only supports a subset of the Java Standard Library. Consequently some Java libraries may not work as expected in the JavaScript environment;
	\item \textbf{No support for Reflections}: J2CL does not provide support for \java{java.lang.reflect.*} or any type of runtime class introspection, including all methods on \java{java.lang.Class} that return \java{java.lang.reflect} objects;
	\item \textbf{No Support for Enum Reflective APIs}: J2CL does not support \java{Class.getEnumConstants} and \java{Enum.valueOf} APIs;
	\item \textbf{No Bound Checks on Array Access}: J2CL does not perform checks on array access boundaries;
	\item \textbf{Limitations of JRE Emulation}: J2CL provides an emulation of a significant portion of the Java Standard Library (JRE). However, it is not possible to support all of the APIs in a web platform. APIs such as \java{java.net.*} are deliberately omitted. Shared code that utilizes these APIs can overcome this limitation by super-sourcing the classes and providing a J2CL-specific alternative implementation;
	\item \textbf{Interoperability with Javascript requires changes in existent code}: J2CL requires the use of additional annotations for existing classes to function in JavaScript. The use of these annotations allows J2CL to properly translate the Java code into JavaScript and ensures that it will work as expected in the web environment.
\end{itemize}

\paragraph{Conclusions} The versatility of J2CL is a noteworthy strength, however, in certain contexts it can also be perceived as a drawback. The desire to leave most existing classes untouched is one of the reasons why J2CL may not be the ideal solution for this project. The aim is to minimize the modifications required, and J2CL may not align with this goal as it often requires changes to classes to work within a web environment. As a result, alternative tools that better align with the desired outcome may be more suitable. Additionally, the uncertainty surrounding the need for component rewriting is a significant risk associated with the use of J2CL. It is not always clear if certain components may need to be rewritten in order to use J2CL effectively, which increases the likelihood of unforeseen challenges and significant time and resource investments.
\section{Kotlin Multiplatform}
\label{sec:kotlin-multiplatform}

\begin{info}[Anticipation:]
	The creation of a proof of concept using the Kotlin Multiplatform framework was successful. An exhaustive explanation about the design and how everything was implemented will be discussed in the dedicated \fullref{chap:design} and \fullref{chap:implementation}. For now, only a brief explanation of how Kotlin Multiplatform works will be provided.
\end{info}

One of the main advantages of Kotlin is its support for multiplatform programming. It helps in keeping the flexibility and advantages of native programming while cutting down on the effort spent writing and maintaining the same code for several platforms. Referring to \fullref{fig:kotlin-mp}:

\centerImage{figures/kotlin-multiplatform.png}{Kotlin Multiplatform - Platforms~\cite{KotlinMu7:online}}{kotlin-mp}{0.5}

\begin{itemize}
	\item The language, basic tools, and core libraries are all part of \emph{Common Kotlin}. Common Kotlin code runs on all systems and is portable;
	\item It is possible to use Kotlin platform-specific versions for platform interoperability. Extensions to the Kotlin language as well as platform-specific libraries and tools are included in the \emph{Kotlin/JVM}, \emph{Kotlin/JS}, and \emph{Kotlin/Native} platform-specific versions of the language. Through these platforms it is possible to access the platform native code (JVM, JS, and Native) and use all the native features.
\end{itemize}

Kotlin Multiplatform~\cite{KotlinMu7:online} may have many applications, but the following are some of the most prevalent ones:

\begin{itemize}
	\item \textbf{Creating Android, iOS, and web apps}: By using shared code, the amount of business logic that front-end developers have to create is decreased. This improves the efficiency of product implementation while requiring less coding and testing for the specific platform;
	\item \textbf{Creating a multiplatform library}: Using shared code and platform-specific components if needed, a multiplatform library that has been distributed may become a classic dependency;
	\item \textbf{Building a full-stack web app}: The two main targets are Kotlin/JVM (for the server) and Kotlin/JS (for the client). The shared code, mainly consists in the model of the application, but can also contains common logic that may run on both the server and the client.
\end{itemize}

Kotlin Multiplatform enables code sharing through its mechanisms. The source code is organized into source sets, each targeting a specific platform. \fullref{fig:kotlin-mp-sourcesets} shows the dependencies among source sets. As shown, if there is business logic that applies to all platforms, it can be shared in the common source set, eliminating the need to write the same code multiple times.

\centerImage{figures/sourcesets.png}{Kotlin Multiplatform - Source set dependencies~\cite{Sharecod25:online}}{kotlin-mp-sourcesets}{1}

\subsection{Handling Third-Party Dependencies}
\label{ssec:handling-third-party-dependencies}
All softwares requires a collection of libraries to work smoothly. A Kotlin Multiplatform project could depend on multiplatform libraries that are compatible with all target platforms, platform-specific libraries, and even other multiplatform projects~\cite{Addingde33:online}.\newline

To include a library dependency, the build configuration must me modified. When using Gradle as the build tool, the target file is \textit{build.gradle(.kts)}, located in the shared directory of the project. It is possible to specify the required library dependency in the dependencies block using the appropriate type (e.g., \kotlin{implementation}, or \kotlin{api}).\newline

Each source set is automatically dependent on the Kotlin standard library (stdlib). The platform-specific version of the library is used in the platform-specific source sets, while a common standard library is included in the remaining sets.

\paragraph{Dependency on a Platform Specific Library} Libraries that are platform-specific must be specified in the correct source set block. It is impossible to set dependencies that are platform-specific libraries in the common source set. For example, since the Apache Common library~\cite{ApacheCo51:online} is not available for Javascript it can be added only to a \textit{jvmMain} source set.

\paragraph{Dependency on a Multiplatform Library} Libraries that adopt Kotlin Multiplatform technology can be imported by specifying the dependency in the common source sets block. The platform-specific version of the library is automatically added to every source-set.

\paragraph{Dependency on a Multiplatform Project} To use another multiplatform project as a dependency, it is possible to add it to the source set that requires it. If the dependency is needed in all source sets, it must be added to the common source set. By doing so, similarly to what happens when adopting a multiplatform library, each source set automatically inherits the correct version.
