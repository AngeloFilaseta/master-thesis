%!TEX root = ../thesis-main.tex
\chapter{\conclusionsname}
\label{chap:conclusions}
The objective of this thesis was clear, but the solution to achieve was not immediately apparent. An agile project development methodology helped in gradually reaching a solution step by step. A long analysis phase was useful to identify potential solutions, but many of these solutions were found to have significant drawbacks that made them unsuitable.\newline

\centerImage{figures/swingui.png}{Dodgeball simulation in Alchemist Swing UI}{swingui}{1}

Kotlin Multiplatform was eventually identified as the best solution for this particular scenario. It is a relatively new technology with the potential to grow, allowing the Alchemist Web Render project to do the same. By creating an initial proof of concept, it was possible to demonstrate that the project's goal could be achieved by developing a solid and well-architected solution.\newline

An example dodgeball simulation is presented, where some nodes pass a ball to each other randomly, and each node keeps count of how many times it receives the ball. A sample frame of this simulation can be displayed in the classic swing UI, as shown in \fullref{fig:swingui}.\newline

\centerImage{figures/web-renderer.png}{Dodgeball simulation in Alchemist Web Renderer}{web-renderer}{0.6}

Using the Alchemist Web Renderer, the same simulation can be monitored, an exaple of a frame is depicted in \fullref{fig:web-renderer}.The resulting image in this second case would have been exactly the same, indipendentely by the fact that it was rendered using the stadia like approach or the everything in browser approach. The ``effect" used to personalize the colors of the nodes in this visualization is not the same used in the swing UI, but it has been created using almost the same principles so that it was possible to visualize a similar image. The node color is black if it currently has got the ball in both the images. The nodes slowly shift towards other colors depending on how many time they received a ball.\newline

At present, the project remains in its nascent stage, and a considerable number of features need to be incorporated. Some of these potential features are described in \fullref{sec:future-works}. The principal aim of this thesis was to establish a solid foundation that would facilitate the seamless addition of features in the future, while minimizing modifications in the existing architecture.\newline

\centerImage{figures/performance-total.png}{Total time from request to visualization comparison}{performance-total}{0.6}

At the current stage of development, profiling performance may not be a highly useful exercise, as there are numerous aspects of the project that can be improved. It is worth noting that the primary objective of this research was not to achieve optimal performance, which remains a significant challenge in this particular scenario. Therefore, the focus has been primarily on establishing a solid foundation that can facilitate the development of new features with relative ease, while addressing the known performance issues as development progresses.\newline

Along with some considerations, some data is still being presented. The graph depicted in \fullref{fig:performance-total} illustrates the relationship between the number of nodes within the environment and the time (expressed in milliseconds) taken to visualize it. The measurement denotes the average time required to display the environment, beginning from the moment the client sends the request until the environment is rendered on the web page, with a fixed image size of 1000x1000 pixels. The measurements were performed on a single machine, where both the Server and the Client components are located. For this motivation the transmission time is not taken into account. The machine has limited hardware capabilities, and is characterized by the following specifications:

\begin{itemize}
	\item \textbf{Processor}: Intel(R) Core(TM) i5-2520M CPU @ 2.50GHz
	\item \textbf{RAM}: 8GiB System memory
	\item \textbf{GPU}: 2nd Generation Core Processor Family Integrated Graphics Controller
\end{itemize}

\centerImage{figures/performance-render.png}{Render operation time comparison}{performance-render}{0.6}

Two main pieces of information pop out from the graph. As it can be seen, there is a blatant linear dependency between the number of nodes in the environment and the time that is required for the operation to be accomplished. This behaviour is expected, as a growth in the cardinality of the data elements necessarily means more time needed in computational operations such as the serialization and rendering process.
The Stadia like approach always requires an additional $\approx 1.5$ seconds compared to the Everything in Browser approach. This behavior is pretty unnatural, therefore the aim was to identify the underlying causes.\newline

\fullref{fig:performance-render} shows the average time required for the completion of the render operation for each of the two different approaches. Note that the two operations require more or less the same time. Considering that in the Stadia apporach the render operation is achieved in a JVM, it is a fairly expected result for this strategy to be a little faster.\newline

\centerImage{figures/performance-serialization.png}{Serialization time comparison}{performance-serialization}{0.6}

\fullref{fig:performance-serialization} shows the differences in time of the two approaches in the serialization process executed by the Server. In the Everything in browser approach, the file to serialize is an \kotlin{EnvironmentSurrogate} class, while in the Stadia like approach it is a \kotlin{Bitmap}. The serialization of the surrogate classes is optimized, while the way the \kotlin{Bitmap} class is serialized could be improved. Nevertheless, the differences in time are rather unrelevant, as the values are very low and insignificant compared to the grand total.\newline

Finally, the differences in time for the deserialization operation are shown in the graph in Figure \fullref{fig:performance-deserialization}. It is now clear that the real divergences in performance is caused by the deserialization operation. This is somewhat unnatural, as the image that the client needs to deserialize is always of the same size and the quantity of nodes should be irrilevant. This is almost certainly caused by the deserialization technique that was used, as the library used for the rendering operation does not offer very good API for obtaining the image in a compact serializable format. This problem is remarked in \fullref{sec:future-works}. Fortunately, the performance issue is not related to the entire system architecture but rather to a specific implementation detail.\newline

A table containing all the data that were used to render the graph is shown in \fullref{fig:performance-table}.\newline

\centerImage{figures/performance-deserialization.png}{Deserialization time comparison}{performance-deserialization}{0.6}

In conclusion, this project thesis has successfully fulfilled its objective of creating a foundation for the future works of the Alchemist Web Renderer project, and provides a clear path forward for continued growth and progress.\newline

\centerImage{figures/table.png}{Table of performance comparison}{performance-table}{1}

\section{Future Works}
\label{sec:future-works}
The objective of this project thesis was to prove the feasibility of developing a flexible and cross-platform renderer for the Alchemist Simulator and to lay the foundation for a solid and functional structure for future works. A robust architecture has been established that can serve as the foundation for future advancements in this field. With this foundation in place, it is now possible to progressively add new features and capabilities that can build upon and enhance the existing structure. The following features are among the most notable and yet to be implemented:
\begin{itemize}
	\item \textbf{Improvement in Performances}: An analysis on how to enhance the system's performance is necessary, considering the data presented in \fullref{chap:conclusions}. The performance of this type of system will always be crucial, and even if most of the issues related to serialization are resolved, it may not be sufficient. However, there are several strategies that could be implemented to circumvent this problem:
	\begin{itemize}
		\item \textbf{Best Effort Strategy}: by using this strategy, only the most recent information is displayed while the simulation continues to run, resulting in the loss of some events. Although this approach is already implemented, it could also be rethought using WebSockets. This strategy is efficient in terms of time, but is not ideal for simulations where the precision factor is crucial;
		\item \textbf{Wait Strategy}: the Simulation Engine halts until the current state of the environment is rendered and displayed to the user. This technique necessitates the use of WebSockets, which will be elaborated later on in this list.
	\end{itemize}
	\item \textbf{Batch Mode Support}: Alchemist provides the ability to run multiple simulations using a single configuration that specifies multiple parameters. However, batch mode is not yet supported by the Alchemist Web Renderer project. To implement this feature, both the structure of the Server state and the client-side GUI needs to be updated. The API endpoints behaviors will require modification as well.
	\item \textbf{Websockets for Pull and Push operations}: Currently, the system operates on a REST architecture, where clients send requests to the server, which responds with the requested information. The server never actively sends data to clients. To change the interaction approach, the system could be updated to use a pull-push Websocket architecture, which would allow the server to push data to clients when needed (for example everytime the environment gets updated). This approach would require some changes to the way the client and server interact, but the underlying logic of the system should not change drastically.
	\item \textbf{Incarnations Support}: Each Incarnation in the project represents a distinct world with a unique concentration type and structure. Currently, the nodes of environments only supports position and do not contains information about the concentration. To support a particular Incarnation, it is necessary to create specific surrogate classes starting from the original concentration classes of that Incarnation. Mapping functions from the original class to the surrogate one should also be created. Once these steps have been completed, the polymorphic serializer will automatically handle the serialization and deserialization process for the supported Incarnations.
	\item \textbf{SVG based Renderer}: The SVG format offers several significant advantages over raster images. In order to take advantage of these benefits, a library that specializes in vector image creation must be adopted to create a Render implementation.
	\item \textbf{Body Compression Optimization}: Ktor offers the ability to compress the body of HTTP messages using the gzip algorithm. The aim is to significantly reduce the size of the payload being sent over the network, resulting in faster transfer speeds and lower bandwidth usage. While gzip is an effective algorithm, it may not always be the most efficient choice, especially for real-time compression scenarios. To address this issue, Ktor provides the flexibility to create custom components that deal with compression~\cite{Compress32:online}. A possible algorithm that could be used in this case is the Zstandard~\cite{Zstandar68:online} from Facebook, which is a fast lossless compression algorithm that is specifically designed for real-time compression scenarios. In order to accomplish this objective, it is necessary to design and develop specific components that can be integrated into the Ktor project specific configuration.
	\item \textbf{Other Serialization Format Support}: The current implementation of the Alchemist Web Renderer project is limited to utilizing the JSON format for serialization. While this choice was made for valid reasons, exploring other serialization formats or adapting the format based on the project's development or production stage could offer benefits. The \textit{kotlinx.serialization} library offers a wide range of formats, and the ktor library integrates smoothly with it, making it simple to switch between formats. To achieve this objective, the necessary dependencies must be added to the build, and the polymorphic serialization issue discussed in \fullref{ssec:polymorphic-serialization} must be addressed. Once the Server is properly configured for content negotiation, ktor will be able to seamlessly handle different serialization formats.
	\item \textbf{Use platform specific libraries for Renderer component development}: In ~\fullref{ssec:renderer} it was discussed how the Renderer component can not use any platform-specific library. Many popular rendering and animation libraries are developed for JavaScript. However, the possibility to run JavaScript on a JVM was never pointed out as an option. It would be necessary to conduct a study to ascertain whether a satisfactory outcome can be obtained.
\end{itemize}
