%!TEX root = ../thesis-main.tex
\chapter{\introductionname}
\label{chap:introduction}
\section{Background}
\label{sec:background}
In order to provide some context, this chapter will briefly touch on what the Alchemist Simulator is and how it works. Some feasible designs and architecture used in literature are described before explaining how they were used in this particular project, what the main objective of this thesis is and the motivations behind it.
\subsection{The Alchemist Simulator}
\label{ssec:the-alchemist-simulator}
\paragraph{Introduction} Alchemist~\cite{alchemist} is an open-source, extensible and stochastic simulator that runs on the Java Virtual Machine (JVM), created by the University of Bologna. It allows for the simulation of scenarios related to pervasive, aggregate and nature-inspired computing. The software is available on GitHub, and is distributed under the GNU GPLv3+ license with linking exception.

\paragraph{Metamodel} Alchemist's world is made up of the following entities:
\begin{itemize}
	\item \textbf{Molecule}: The name of a data item. In an imperative programming language, a molecule would be a variable name;
	\item \textbf{Concentration}: The value associated to a \textit{molecule}. In an imperative programming language, a concentration would be a value associated to a variable;
	\item \textbf{Node}: A container of \textit{molecules} and \textit{reactions}, living inside an \textit{environment};
	\item \textbf{Environment}: A container for \textit{nodes}. Some utilities are also included, for example an \textit{Environment} can locate the position of a \textit{node} in the space, or it can calculate the distance between two \textit{nodes};
	\item \textbf{Linking rule}: A function of the current status of the environment. It associates a neighborhood to each node;
	\item \textbf{Reaction}: An event that can change the status of the \textit{Environment}. Reactions are defined by a list of conditions (possibly none), one or more actions and  a Time Distribution. The frequency at which a reaction can happen depends on various factors:
	\begin{itemize}
		\item A static “rate” parameter;
		\item The value of each condition;
		\item A “rate equation”, that combines the static rate and the value of conditions, giving back an “instantaneous rate”;
		\item A time distribution.
	\end{itemize}
	A visual representation of how a Reaction work is proposed in \fullref{fig:alchemist-reaction};
	\centerImage{figures/reaction.png}{Alchemist Behavior in Terms of Reactions~\cite{TheAlche16:online}}{alchemist-reaction}{0.8}
	\item \textbf{Condition}: A function that returns a boolean and a number starting from an \textit{Environment}. If the condition does not hold (i.e., its current output is false), the reaction to which it is associated cannot run.
	The outputted number may or may not influence the reaction speed, depending on the reaction and its time distribution;
	\item \textbf{Action}: Models a change in the \textbf{Environment}.
\end{itemize}
\fullref{fig:alchemist-metamodel} depicts a visual representation of the model described.

\centerImage{figures/model.png}{The Alchemist Simulator Metamodel~\cite{TheAlche16:online}}{alchemist-metamodel}{1}

\paragraph{Incarnations} The names in the metamodel are modeled after classical chemical words. This is primarily due to Alchemist's origins as a chemical-oriented multi-compartment stochastic simulation engine capable of supporting compartment (node) mobility while maintaining good performance. Alchemist's capabilities are not restricted to this. While in chemistry, Molecule and Concentration have highly specific definitions, in Alchemist, their concept can be generalized. An \textit{Incarnation} in Alchemist includes a type definition of concentration and possibly a set of specific conditions, actions and, possibly but rarely, environments and reactions that operate on such types. In other words, an Incarnation is a concrete instance of the Alchemist metamodel.\newline
Different \textit{Incarnations} can represent vastly different universes. By now, Alchemist supports the following Incarnations:
\begin{itemize}
	\item \textbf{SAPERE Incarnation}: The simulator's first stable incarnation. It was developed in the context of the SAPERE EU project~\cite{SAPEREon48:online}. The core of SAPERE is the concept of Live Semantic Annotation (LSA), which is a description of a resource (for example a sensor, service, actuator, etc.) that always maps the current resource status (could be considered a prelude to the currently famous digital twin concept);
	\item \textbf{Protelis Incarnation}: Protelis~\cite{Protelis97:online} is a language. Its goal is to make it easier to build a resilient and well-behaved networked system out of a variety of potentially mobile devices. Protelis is intended for the "aggregate programming" paradigm, which is a way of thinking about and decomposing problems that can be solved using a network of distributed sensors and computers;
	\item \textbf{Biochemistry Incarnation}: An Alchemist incarnation that was created to provide support for biochemical reactions which occur inside a biological cell or a group of cells that share a common environment~\cite{Biochemi16:online};
	\item \textbf{SCAFI Incarnation}: ScaFi~\cite{ScaFiAgg69:online} (Scala Fields) is a Scala-based Aggregate Programming library and framework. It implements a variant of the Higher-Order Field Calculus (HOFC) operational semantics and provides a platform and API for simulating and executing Aggregate Computing systems and applications.
\end{itemize}

\subsection{Exploring Feasible Designs: Stadia-like Streaming and Everything in Browser}
\label{ssec:exploring-feasible-designs-stadia-like-streaming-and-everything-in-browser}
\paragraph{Google Stadia} A cloud-based gaming platform called Stadia was created by the Google company. It enables users to play video games without the need of owning expensive hardware or top-tier graphics cards. The games audiovisual (AV) data are broadcasted back over the internet by powerful servers once the user input is received and processed.\newline

\centerImage{figures/stadia-topology.png}{Google Stadia Topology~\cite{AFirstLo55:online}}{stadia-topology}{0.8}

Thanks to Stadia architecture, users can play high-end games on computers or even mobile devices that would not typically be able to run them.\newline

To deliver the game content to the user, the system combines cloud computing, streaming technology, and data compression. The architecture works similarly to a streaming service, with the exception that data is bidirectional, with inputs flowing from the player and the provider streaming AV data which are a direct results of these inputs.\newline

In a traditional multiplayer setup, players' actions are typically sent to a server or directly to other players' devices to update the game state via P2P. With Stadia, however, the architecture shifts to a centralized, local, big network, also shown in \fullref{fig:stadia-topology}. This means that instead of sending information over the public internet, Stadia instances communicate directly with one another within the same network. As a result, the server is the only component that actively processes game data, while the user's device simply receives the information passively~\cite{AFirstLo55:online}.

\paragraph{Everything in Browser} This strategy refers to a design philosophy in which an application's user interface, logic, and data storage are all executed entirely within a web browser, almost independent of any external servers or dependencies. This enables a user experience that is easier to use and more seamless, as well as better offline functionality and increased security. This can be often achieved through the use of JavaScript and related technologies, like the WebAssembly (or Wasm) programming language.\newline

Since this approach relies on languages that are not specific to any particular platform, the software can run seamlessly on various operating systems and devices without the need for additional setup. It is not the operative system that executes the code, the browser does.
All major web browsers supports these type of languages as they have become a standard, enabling their usage across a variety of devices and platforms.

\section{Objectives and Motivations}
\label{sec:objectives-and-motivations}
The Alchemist simulator already uses some GUI systems, including the \textit{alchemist-swingui} sub-project (implemented with Java Swing) and the \textit{alchemist-fxui} sub-project (implemented with Java FX).\newline

The desire is to build a new display and remote control system for Alchemist. As already mentioned, the simulator runs on the JVM (it has parts in Java, Kotlin, Scala, and possibly even parts in Groovy). The long-standing problem, which has been pending for a while, is to have a very flexible render, capable of being dynamically moved from a client to a server machine.\newline

\centerImage{figures/use-case.png}{UML Use Case Diagram}{use-case}{0.6}

The following is a detailed description of a use case that the desired system should satisfy:\newline

The simulator starts on a well-equipped server and begins to simulate. Two users want to view the progress and interact with the simulator by connecting to the server. The first user has a workstation with a very powerful network and state-of-the-art hardware, the other uses a Raspberry PI on a 3G network that is very slow. Since the first user is in a more comfortable condition, it would be ideal for the renderer to work directly within his browser. On the other hand, the user on the mini-PC has serious performance problems: in his case, the rendering should compute on the server side and only the input and output should be transmitted to the browser side. Apart from performance, the experience for the two users should be identical. Notice how, in terms of functionalities, there are no differences between a thick client and a thin client. The UML Use Case Diagram in \fullref{fig:use-case} could be simplified to have a single Client actor.\newline

Generating an image starting from a structured indication can require a good amount of computational resources and processing power to be efficient. This task could be demanding, especially when it is required to generate high-resolution or particularly complex images. To achieve optimal results, specialized hardware is surely useful too. The key factor for the good success of this project is the creation of a dynamic and adaptable architecture for generating images. This architecture should be able to use different strategies for generating images, and should be able to dynamically choose the best one based on a series of factors. This would enable the system to optimize the image generation process, and produce high-quality images in a more efficient and timely manner.\newline

\noindent A more detailed description of the two strategies is now given with the help of some images that shows the ordered interactions.  Note that there is a clear mapping with the two designs already illustrated in \fullref{ssec:exploring-feasible-designs-stadia-like-streaming-and-everything-in-browser}.\newline

In a \textbf{Stadia-like} approach, shown in \fullref{fig:stadia-approach}, the Client would request a \textit{Renderer Environment}. In this case the Server will make the rendering computation by creating a visual representation of the Environment using the \textit{Environment State} offered by the Simulation API.
After finishing the calculation, the result is sent back to the Client which can now make it visible for the user to see. The visual representation can be anything that may be visualized on a browser, such as a raster or a vector image. This approach is ideal when the client machine has very weak hardware capabilities and is not ideal when multiple thin clients are connected because the Server would generates lot of \textit{Rendered Environments} wasting a lot of resources.

\centerImage{figures/stadia-approach.png}{Stadia Like Approach}{stadia-approach}{0.47}

\begin{warn}[Note:]
	Some sort of cache could be used to prevent resources wasting.
	For example, a sub-strategy could be to send to the client a \textit{Rendered Environment}, which is not completely up to date with the current Environment State given that is was created for another client not too long prior. Although, it is still important to mention that in some cases, by sending an outdated version of the environment, the experience may not be suitable for the user desires. In particular circumstances, especially when it comes to simulation, it would be desirable not to lose a single event.
\end{warn}

In an \textbf{Everything in Browser} approach, shown in \fullref{fig:e-i-b-approach} things works differently. The Client would request the \textit{Environment State} to the server. After retrieving it from the Simulation API, the server sends it back. The client is now responsible for generating the \textit{Rendered Environment} which will be visualized on the browser after the computation, that requires the \textit{Environment State} as input, is over. This approach is ideal when the client machine has very good hardware capabilities. If all the clients were to use this approach, it would also be beneficial on the server side, as complex computations always happens on different machines. This approach should not be used by thin client machines, as the rendering operation would cost too much time, and it would be impossible to keep up with the \textit{Environment State} on the Server.

\centerImage{figures/everything-in-browser-approach.png}{Everything in Browser Approach}{e-i-b-approach}{0.47}

\begin{warn}[Note:]
	This \textit{Everything in Browser} approach is not pure, because a Server is still needed to retrieve information about the Environment State. However, a Simulation running on an external server is not a strict requirement in this architecture. The point of this approach is the ability of the client machine to render the Environment by simply having a serialized form of it, which can be retrieved from any source.
\end{warn}
